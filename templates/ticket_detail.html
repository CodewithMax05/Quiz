{% extends "base.html" %} <!-- Erbt von Basis-Template -->

<!--
Ticket-Detail-Seite enthält:
    1. Ticket-Übersicht mit Betreff und Status
    2. Chat mit Datums-Separatoren
-->

{% block head %}
    <!-- Seiten-spezifisches Stylesheet für Ticket-Details -->
    <title>Ticket #{{ ticket.id }}</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/styles_ticket_detail.css') }}"/>
    <!-- Font Awesome für Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
{% endblock %}

{% block body %}
<div class="page-wrapper">
    <div class="container">
        
        <!-- TICKET-ÜBERSCHRIFT: Betreff des Tickets -->
        <h1 class="support-title">{{ ticket.subject }}</h1>

        <!-- STEUERUNGSLEISTE: Enthält Navigation, Status und Aktionen -->
        <div class="controls-row">
            <!-- LINKE SEITE: Zurück-Button zur Ticket-Übersicht -->
            <div class="controls-left">
                <a href="{{ url_for('tickets_overview') }}" class="back-button sound-button">
                    <i class="fas fa-chevron-left"></i> <span class="btn-text">Zurück</span>
                </a>
            </div>

            <!-- MITTE: Status-Anzeige -->
            <div class="controls-center">
                {% if ticket.status == 'open' %}
                    <span class="status-badge status-open"><i class="fas fa-lock-open"></i> Offen</span>
                {% else %}
                    <span class="status-badge status-closed"><i class="fas fa-lock"></i> Geschlossen</span>
                {% endif %}
            </div>

            <!-- RECHTE SEITE: Ticket-Aktionen (Schließen/Öffnen/Löschen) -->
            <div class="controls-right">
                <!-- Formular zum Umschalten des Ticket-Status -->
                <form method="POST" action="{{ url_for('toggle_ticket_status', ticket_id=ticket.id) }}">
                    <!-- CSRF-Schutz-Token -->
                    <input type="hidden" name="csrf_token" value="{{ csrf_token() }}">
                    {% if ticket.status == 'open' %}
                    <!-- Button zum Schließen des Tickets (nur wenn offen) -->
                    <button type="submit" class="action-button btn-close sound-button" title="Ticket schließen">
                        <i class="fas fa-lock"></i> <span class="btn-text">Schließen</span>
                    </button>
                    {% else %}
                    <!-- Button zum Wiederöffnen des Tickets (nur wenn geschlossen) -->
                    <button type="submit" class="action-button btn-reopen sound-button" title="Ticket wieder öffnen">
                        <i class="fas fa-lock-open"></i> <span class="btn-text">Öffnen</span>
                    </button>
                    {% endif %}
                </form>

                <!-- Löschen-Button (NUR für Admins und NUR bei geschlossenen Tickets) -->
                {% if is_admin and ticket.status == 'closed' %}
                <form method="POST" action="{{ url_for('admin_delete_ticket', ticket_id=ticket.id) }}" onsubmit="return confirm('Möchten Sie dieses Ticket wirklich löschen? Diese Aktion kann nicht rückgängig gemacht werden.');">
                    <!-- CSRF-Schutz-Token -->
                    <input type="hidden" name="csrf_token" value="{{ csrf_token() }}">
                    <button type="submit" class="action-button btn-delete sound-button" title="Ticket löschen">
                        <i class="fas fa-trash"></i>
                    </button>
                </form>
                {% endif %}
            </div>
        </div>

        <!-- CHAT-CONTAINER: Scrollbarer Bereich für Nachrichtenverlauf -->
        <div class="chat-scroll-wrapper" id="chat-container">
            <!-- Lade-Indikator für ältere Nachrichten (wird per JavaScript ein/ausgeblendet) -->
            <div id="chat-loading" style="display: none;">
                <i class="fas fa-spinner fa-spin"></i> Lade ältere Nachrichten...
            </div>

            <!-- NACHRICHTEN-VERLAUF: Iteriert durch alle Nachrichten des Tickets -->
            {% set current_date = namespace(value=None) %}
            {% for message in messages %}
                <!-- Datum jedes Nachrichten-Eintrags extrahieren -->
                {% set message_date = message.created_at.strftime('%d.%m.%Y') %}
                
                <!-- DATUMS-SEPARATOR: Zeigt Datumswechsel im Chat an -->
                {% if current_date.value != message_date %}
                    <div class="date-separator">
                        <span>{{ message_date }}</span>
                    </div>
                    {% set current_date.value = message_date %}
                {% endif %}
                
                <!-- EINZELNACHRICHT: CSS-Klasse unterscheidet zwischen Admin und User -->
                <div class="message {{ 'admin-message' if message.sender_type == 'admin' else 'user-message' }}">
                    <!-- NACHRICHTEN-KOPF: Absender und Uhrzeit -->
                    <div class="message-header">
                        <span class="sender-name">
                            {% if message.sender_type == 'admin' %}Support{% else %}{{ message.sender_name }}{% endif %}
                        </span>
                        <span class="message-time">
                            <!-- Zeit in ISO-Format für JavaScript-Konvertierung -->
                            <time class="ticket-time-only" data-iso="{{ message.created_at|to_iso }}">
                                {{ message.created_at.strftime('%H:%M') }}
                            </time>
                        </span>
                    </div>
                    <!-- NACHRICHTEN-INHALT -->
                    <p class="message-content">{{ message.content }}</p>
                </div>
            {% endfor %}
        </div>

        <!-- EINGABEBEREICH: Für neue Nachrichten (nur bei offenen Tickets) -->
        <div class="input-area-wrapper">
            {% if ticket.status == 'open' %}
                <!-- Formular zum Senden neuer Nachrichten -->
                <form class="chat-form" method="POST" action="{{ url_for('ticket_detail', ticket_id=ticket.id) }}">

                    <!-- CSRF-Schutz-Token -->
                    <input type="hidden" name="csrf_token" value="{{ csrf_token() }}">
                    
                    <!-- Textarea für Nachrichteneingabe mit Zeichenlimit -->
                    <textarea name="message_content" class="chat-textarea" 
                              maxlength="500" placeholder="Schreibe eine Nachricht..." required 
                              oninput="updateCharCount(this, 'counter-chat')"></textarea>
                    
                    <!-- UNTERE LEISTE: Zeichenzähler und Senden-Button -->
                    <div class="input-actions">
                        <span id="counter-chat" class="char-counter">0 / 500</span>
                        <button type="submit" class="send-button sound-button">
                            <i class="fas fa-paper-plane"></i> Senden
                        </button>
                    </div>
                </form>
            {% else %}
                <!-- Hinweis bei geschlossenen Tickets (keine Eingabe möglich) -->
                <div class="closed-notice">
                    <i class="fas fa-lock"></i> Dieses Ticket ist geschlossen.
                </div>
            {% endif %}
        </div>

    </div>
</div>

<script>
    // ---------------------------------------------------------------------
    // FUNKTION: updateCharCount
    // ZWECK: Zeichenzähler für Textarea (max. 500 Zeichen)
    // ---------------------------------------------------------------------
    function updateCharCount(textarea, counterId) {
        const maxLength = 500;
        const currentLength = textarea.value.length;
        const counter = document.getElementById(counterId);
        counter.textContent = `${currentLength} / ${maxLength}`;
        
        // Farbwechsel bei Erreichen des Limits
        if (currentLength >= maxLength) {
            counter.style.color = '#fc8181'; // Rot
        } else {
            counter.style.color = '#aaa';    // Grau
        }
    }

    // ---------------------------------------------------------------------
    // FUNKTION: convertTicketTimeElements
    // ZWECK: Konvertiert UTC-Zeiten zu lokaler Zeit (nur HH:MM)
    // ---------------------------------------------------------------------
    function convertTicketTimeElements(root = document) {
        root.querySelectorAll && root.querySelectorAll('time.ticket-time-only').forEach(el => {
            const iso = el.dataset.iso || el.getAttribute('datetime') || el.textContent.trim();
            if (iso) {
                try {
                    const date = new Date(iso);
                    // Nur die Uhrzeit extrahieren (HH:MM) in lokaler Zeit
                    const hours = String(date.getHours()).padStart(2, '0');
                    const minutes = String(date.getMinutes()).padStart(2, '0');
                    el.textContent = `${hours}:${minutes}`;
                    el.setAttribute('datetime', iso);
                    el.classList.remove('ticket-time-only');
                    el.classList.add('ticket-time-done');
                } catch (e) {
                    console.log("Could not parse date:", e);
                }
            }
        });
    }

    // ---------------------------------------------------------------------
    // FUNKTION: extractTime
    // ZWECK: Extrahiert Uhrzeit aus ISO-String (für nachgeladene Nachrichten)
    // ---------------------------------------------------------------------
    function extractTime(isoString) {
        try {
            const date = new Date(isoString);
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            return `${hours}:${minutes}`;
        } catch (e) {
            // Fallback: Versuche Uhrzeit aus String zu extrahieren
            const timeMatch = isoString.match(/\b(\d{1,2}:\d{2})\b/);
            return timeMatch ? timeMatch[1] : isoString;
        }
    }

    // ---------------------------------------------------------------------
    // FUNKTION: formatDateForDisplay
    // ZWECK: Formatiert Datum für Datums-Separatoren (TT.MM.JJJJ)
    // ---------------------------------------------------------------------
    function formatDateForDisplay(isoString) {
        try {
            const date = new Date(isoString);
            const day = String(date.getDate()).padStart(2, '0');
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const year = date.getFullYear();
            return `${day}.${month}.${year}`;
        } catch (e) {
            return isoString.split(' ')[0] || isoString;
        }
    }

    // =====================================================================
    // CHAT-LOGIK: Paging & Scrolling für Nachrichtenverlauf
    // =====================================================================
    document.addEventListener("DOMContentLoaded", function() {
        const chatContainer = document.getElementById('chat-container');
        const loadingIndicator = document.getElementById('chat-loading');
        const ticketId = "{{ ticket.id }}";
        
        // Variablen für das Paging
        let currentOffset = 20;     // Anzahl der bereits angezeigten Nachrichten
        let isLoading = false;      // Flag für laufenden Ladevorgang
        let hasMore = true;         // Gibt an ob weitere Nachrichten verfügbar sind
        let lastLoadedDate = null;  // Letztes geladenes Datum für Separatoren

        // 1. Initial ganz nach unten scrollen (neueste Nachricht)
        scrollToBottom();

        function scrollToBottom() {
            setTimeout(() => {
                chatContainer.scrollTop = chatContainer.scrollHeight;
            }, 100);
        }

        // 2. Ticket-Zeiten konvertieren (nur für initial geladene Nachrichten)
        convertTicketTimeElements();

        // 3. Event Listener für das Scrollen nach oben (Nachladen älterer Nachrichten)
        chatContainer.addEventListener('scroll', function() {
            if (chatContainer.scrollTop === 0 && !isLoading && hasMore) {
                loadOlderMessages();
            }
        });

        // -----------------------------------------------------------------
        // FUNKTION: loadOlderMessages
        // ZWECK: Lädt ältere Nachrichten per AJAX nach
        // -----------------------------------------------------------------
        async function loadOlderMessages() {
            isLoading = true;
            loadingIndicator.style.display = 'block';

            const oldHeight = chatContainer.scrollHeight;

            try {
                // AJAX-Request an API-Endpunkt
                const response = await fetch(`/api/ticket/${ticketId}/messages?offset=${currentOffset}`);
                if (!response.ok) throw new Error('Netzwerkfehler');
                
                const data = await response.json();
                
                if (data.messages && data.messages.length > 0) {
                    // Nachrichten am Anfang einfügen
                    prependMessages(data.messages);
                    currentOffset += data.messages.length;
                    hasMore = data.has_more;

                    // Scroll-Position anpassen, damit der Viewport stabil bleibt
                    requestAnimationFrame(() => {
                        const newHeight = chatContainer.scrollHeight;
                        chatContainer.scrollTop = newHeight - oldHeight;
                    });
                } else {
                    hasMore = false;
                }

            } catch (error) {
                console.error("Fehler beim Laden:", error);
            } finally {
                isLoading = false;
                loadingIndicator.style.display = 'none';
            }
        }

        // -----------------------------------------------------------------
        // FUNKTION: prependMessages
        // ZWECK: Fügt nachgeladene Nachrichten in den Chat-Container ein
        // -----------------------------------------------------------------
        function prependMessages(messages) {
            let html = '';
            let lastDate = lastLoadedDate;
            
            // Nachrichten in umgekehrter Reihenfolge (älteste zuerst)
            messages.reverse().forEach(msg => {
                const isSupport = (msg.sender_type === 'admin');
                const cssClass = isSupport ? 'admin-message' : 'user-message';
                const senderDisplay = isSupport ? 'Support' : msg.sender_name;
                const messageDate = formatDateForDisplay(msg.created_at_iso);
                
                // Datums-Separator einfügen, wenn sich das Datum ändert
                if (lastDate !== messageDate) {
                    html += `
                    <div class="date-separator">
                        <span>${messageDate}</span>
                    </div>
                    `;
                    lastDate = messageDate;
                }
                
                // HTML für Nachricht mit ISO-Zeit im data-iso Attribut
                html += `
                <div class="message ${cssClass}">
                    <div class="message-header">
                        <span class="sender-name">${escapeHtml(senderDisplay)}</span>
                        <span class="message-time">
                            <time class="ticket-time-only" data-iso="${msg.created_at_iso}">${extractTime(msg.created_at_iso)}</time>
                        </span>
                    </div>
                    <p class="message-content">${escapeHtml(msg.content)}</p>
                </div>
                `;
            });
            
            lastLoadedDate = lastDate;
            // Nachrichten nach dem Lade-Indikator einfügen
            loadingIndicator.insertAdjacentHTML('afterend', html);
            
            // Ticket-Zeiten für nachgeladene Nachrichten konvertieren
            convertTicketTimeElements();
        }
        
        // -----------------------------------------------------------------
        // FUNKTION: escapeHtml
        // ZWECK: Escaped HTML-Sonderzeichen zur XSS-Prävention
        // -----------------------------------------------------------------
        function escapeHtml(text) {
            if (!text) return text;
            return text
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }
    });
</script>
{% endblock %}
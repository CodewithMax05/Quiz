<!-- quiz.html -->
{% extends "base.html" %}

{% block head %}
    <link rel="stylesheet" href="{{ url_for('static', filename='css/styles_quiz.css') }}"/>
{% endblock %}

{% block body %}
    <!-- Bestätigungs-Modal -->
    <div class="confirmation-modal" id="confirmationModal">
        <div class="modal-content">
            <h3>Quiz abbrechen?</h3>
            <p>Möchtest du das Quiz wirklich abbrechen?</p>
            <p><strong>Dein aktueller Fortschritt geht verloren.</strong></p>
            <div class="modal-buttons">
                <button class="modal-btn modal-cancel" id="dismissCancelBtn">Weiterspielen</button>
                <button class="modal-btn modal-confirm" id="confirmCancelBtn">Beenden</button>
            </div>
        </div>
    </div>

    <div class="main-quiz-wrapper">
        <div class="header-controls">
            <div class="header-content">
                <div class="timer-container">
                    <svg class="timer-circle" viewBox="0 0 100 100">
                        <circle class="timer-background" cx="50" cy="50" r="45"></circle>
                        <circle class="timer-progress" cx="50" cy="50" r="45"
                                stroke-dasharray="283"
                                stroke-dashoffset="0"></circle>
                    </svg>
                    <div class="timer-text">30</div>
                </div>
                
                <div class="score-display" id="score-display">
                    Score: {{ score }}
                </div>
                
                <button class="cancel-btn" id="cancelQuizBtn">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                        <line x1="18" y1="6"  x2="6" y2="18" stroke="white" stroke-width="2"/>
                        <line x1="6"  y1="6"  x2="18" y2="18" stroke="white" stroke-width="2"/>
                    </svg>
                </button>
            </div>
        </div>

        <div class="quiz-container-wide" 
            data-was-correct="{{ 'true' if was_correct else 'false' }}"
            data-room-id="{{ room_id }}"
            data-initial-time-left="{{ time_left }}">
            <div class="question-box">
                <div class="question-text">
                    {{ question.question }}
                </div>
            </div>

            <div class="options-grid" id="options-grid">
                {% for option in options %}
                <div class="option" data-answer="{{ option }}">
                    {{ option }}
                </div>
                {% endfor %}
            </div>

            <div class="progress-bar">
                Frage {{ progress }} von {{ total_questions }}
            </div>

            <form id="next-form" action="/next_question" method="POST" style="display: none;">
                <input type="hidden" name="csrf_token" value="{{ csrf_token() }}"/>
                <input type="hidden" id="selected-answer" name="answer">
            </form>
        </div>
    </div>
    
    <script>
        class QuizManager {
            constructor() {
                this.socket = null;
                this.roomId = document.querySelector('.quiz-container-wide').dataset.roomId;
                this.hasAnswered = false;
                this.isConnected = false;
                this.reconnectAttempts = 0;
                this.maxReconnectAttempts = 5;
                this.selectedOption = null;
                this.initialTimeLeft = parseInt(document.querySelector('.quiz-container-wide').dataset.initialTimeLeft) || 30;
                this.confirmationModal = null;
                this.isModalOpen = false;
                this.pendingVisibilityChange = false;
                this.allowNavigation = false; 
                this.beforeUnloadHandler = this.beforeUnload.bind(this);
                
                // NEU: Wichtig, um die "Weiterspielen"-Logik zu steuern
                this.modalOpenedByPopstate = false; 

                console.log('Quiz Manager initialisiert für Raum:', this.roomId);

                try {
                    sessionStorage.setItem('quiz_active', '1');
                } catch (e) {
                    console.warn('sessionStorage not available:', e);
                }

                this.setupBrowserNavigation();
                this.setupGlobalEventListeners();
                this.initializeSocket();
                this.setupEventListeners();
                this.setupModal();
                this.updateTimer(this.initialTimeLeft);
                this.keepSessionAlive();
            }

            getCurrentBaseUrl() {
                const progress = this.getCurrentQuestionNumber();
                return `/show_question?q=${progress}`;
            }

            setupBrowserNavigation() {
                // 1) Initial canonical replace
                const baseUrl = this.getCurrentBaseUrl();
                try {
                    history.replaceState({ quiz: true, q: this.getCurrentQuestionNumber(), blocker: false }, document.title, baseUrl);
                    // 2) Push einen separaten Blocker-State
                    history.pushState({ quiz: true, q: this.getCurrentQuestionNumber(), blocker: true }, document.title, baseUrl);
                } catch (e) {
                    console.warn('History initialisation failed:', e);
                }

                window.addEventListener('popstate', (event) => {
                    if (this.allowNavigation) return;

                    if (this.isModalOpen) {
                        // Szenario: Modal ist offen, User klickt "Back" #2.
                        console.log('Popstate: Modal offen. Blockiere "Back" und starte Abbruch.');

                        // 1. SOFORT "forward" aufrufen, um die "Back"-Navigation
                        //    zu kontern und auf dem [blocker: true] state zu bleiben.
                        //    Das stoppt die Neuladung der Seite.
                        try {
                            history.forward();
                        } catch (e) {
                            console.warn('history.forward() in popstate failed:', e);
                        }
                        
                        // 2. Jetzt, da die Seite nicht neu lädt,
                        //    rufe confirmCancel() auf, das den fetch()
                        //    ausführt und DANN per JS weiterleitet.
                        this.confirmCancel(); 
                        return;
                    }

                    // Szenario: Modal ist nicht offen, User klickt "Back" #1.
                    // (Dieser Teil wird jetzt vom Server-Redirect gehandhabt,
                    // aber wir lassen ihn als Fallback drin)
                    console.log('Popstate: Modal geschlossen, zeige Modal.');
                    this.modalOpenedByPopstate = true;
                    this.showConfirmationModal();
                    
                    try {
                        const curBase = this.getCurrentBaseUrl();
                        // Blocker-State wieder anlegen
                        history.pushState(
                            { quiz: true, q: this.getCurrentQuestionNumber(), blocker: true }, 
                            document.title, 
                            curBase
                        );
                    } catch (e) {
                        console.error('FEHLER beim pushState (popstate, modal closed):', e);
                    }
                });
            }

            setupGlobalEventListeners() {
                window.addEventListener('beforeunload', this.beforeUnloadHandler);

                document.addEventListener('visibilitychange', () => {
                    if (document.visibilityState === 'hidden' && !this.hasAnswered && !this.isModalOpen && !this.allowNavigation) {
                        this.pendingVisibilityChange = true;
                    }
                });

                window.addEventListener('focus', () => {
                    if (this.pendingVisibilityChange && !this.isModalOpen && !this.allowNavigation) {
                        this.pendingVisibilityChange = false;
                        this.showConfirmationModal();
                    }
                });
            }

            setupModal() {
                this.confirmationModal = document.getElementById('confirmationModal');
                const cancelBtn = document.getElementById('cancelQuizBtn');
                
                cancelBtn.addEventListener('click', () => {
                    // Markiere, dass das Modal manuell geöffnet wurde
                    this.modalOpenedByPopstate = false;
                    this.showConfirmationModal();
                });
                
                document.getElementById('confirmCancelBtn').addEventListener('click', () => {
                    // Der Parameter `fromPopstate` wurde entfernt, er wurde nicht benötigt.
                    this.confirmCancel();
                });
                
                document.getElementById('dismissCancelBtn').addEventListener('click', () => {
                    // KORRIGIERTE LOGIK:
                    this.hideConfirmationModal();
                    if (this.modalOpenedByPopstate) {
                        // Wenn "Back" das Modal geöffnet hat, müssen wir
                        // `history.forward()` nutzen, um zum Blocker-State zurückzukehren.
                        try {
                            history.forward();
                        } catch (e) { console.warn('history.forward failed', e); }
                    }
                    // Wichtig: Flag immer zurücksetzen
                    this.modalOpenedByPopstate = false;
                });
                
                this.confirmationModal.addEventListener('click', (e) => {
                    if (e.target === this.confirmationModal) {
                        // DIESELBE KORRIGIERTE LOGIK wie bei dismissCancelBtn
                        this.hideConfirmationModal();
                        if (this.modalOpenedByPopstate) {
                            try {
                                history.forward();
                            } catch (e) { console.warn('history.forward failed', e); }
                        }
                        this.modalOpenedByPopstate = false;
                    }
                });
                
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && this.isModalOpen) {
                        // DIESELBE KORRIGIERTE LOGIK wie bei dismissCancelBtn
                        this.hideConfirmationModal();
                        if (this.modalOpenedByPopstate) {
                            try {
                                history.forward();
                            } catch (e) { console.warn('history.forward failed', e); }
                        }
                        this.modalOpenedByPopstate = false;
                    }
                });
            }

            beforeUnload(e) {
                if (!this.allowNavigation && !this.hasAnswered && !this.isModalOpen) {
                    e.preventDefault();
                    e.returnValue = '';
                    this.showConfirmationModal();
                    return '';
                }
            }

            removeBeforeUnloadHandler() {
                window.removeEventListener('beforeunload', this.beforeUnloadHandler);
                window.onbeforeunload = null;
            }

            showConfirmationModal() {
                if (this.confirmationModal) {
                    this.confirmationModal.style.display = 'flex';
                    this.isModalOpen = true;
                    document.body.style.overflow = 'hidden';
                }
            }

            hideConfirmationModal() {
                if (this.confirmationModal) {
                    this.confirmationModal.style.display = 'none';
                    this.isModalOpen = false;
                    document.body.style.overflow = '';
                }
            }

            confirmCancel() { // Parameter entfernt
                this.allowNavigation = true;
                this.removeBeforeUnloadHandler();

                try {
                    sessionStorage.setItem('quiz_cancelled_intentionally', '1');
                    sessionStorage.removeItem('quiz_active');
                } catch (e) {
                    console.warn('sessionStorage remove failed:', e);
                }

                this.hideConfirmationModal();
                this.modalOpenedByPopstate = false;

                if (this.socket) {
                    this.socket.disconnect();
                }

                // Sende Abbruch-Request an den Server.
                try {
                    const csrfEl = document.querySelector('input[name="csrf_token"]');
                    const csrfToken = csrfEl ? csrfEl.value : '';
                    // Sicherstellen, dass CSRF-Token als Form-Daten gesendet wird
                    const body = new URLSearchParams();
                    body.append('csrf_token', csrfToken);


                    fetch("{{ url_for('cancel_quiz') }}", {
                        method: 'POST',
                        headers: {
                            // X-CSRFToken ist nicht nötig, wenn es im Body ist
                            'Content-Type': 'application/x-www-form-urlencoded',
                        },
                        body: body.toString() // Korrekt als String senden
                    }).then(response => {
                        return response.json().catch(() => ({}));
                    }).then(data => {
                        // ERST JETZT, nachdem der Server geantwortet hat,
                        // leiten wir zur Homepage weiter.
                        window.location.href = data.redirect || "{{ url_for('homepage') }}";
                    }).catch(error => {
                        console.error('Fehler beim Abbrechen des Quiz:', error);
                        window.location.href = "{{ url_for('homepage') }}";
                    });
                } catch (e) {
                    console.error('confirmCancel: unexpected error', e);
                    window.location.href = "{{ url_for('homepage') }}";
                }
            }

            keepSessionAlive() {
                setInterval(() => {
                    if (!this.hasAnswered && !this.isModalOpen) {
                        fetch('/quiz_session_status')
                            .catch(error => console.log('Session keep-alive fehlgeschlagen:', error));
                    }
                }, 60000); 
            }

            initializeSocket() {
                console.log('Initialisiere Socket-Verbindung...');
                
                const socketUrl = window.location.origin;
                
                this.socket = io(socketUrl, {
                    transports: ['websocket', 'polling'],
                    upgrade: true,
                    reconnection: true,
                    reconnectionAttempts: this.maxReconnectAttempts,
                    reconnectionDelay: 1000,
                    reconnectionDelayMax: 5000,
                    timeout: 20000
                });

                this.socket.on('connect', () => {
                    console.log('Socket verbunden, ID:', this.socket.id);
                    this.isConnected = true;
                    this.reconnectAttempts = 0;
                    this.joinQuizSession();
                });

                this.socket.on('disconnect', (reason) => {
                    console.log('Socket getrennt:', reason);
                    this.isConnected = false;
                    
                    if (reason === 'io server disconnect') {
                        console.log('Server hat Verbindung getrennt');
                    } else if (reason === 'transport close' || reason === 'ping timeout') {
                        console.log('Netzwerkproblem - versuche Reconnect');
                    }
                });

                this.socket.on('connect_error', (error) => {
                    console.error('Verbindungsfehler:', error.message);
                    this.isConnected = false;
                    this.reconnectAttempts++;
                });

                this.socket.on('reconnect', (attemptNumber) => {
                    console.log('Reconnected nach', attemptNumber, 'Versuchen');
                    this.joinQuizSession();
                });

                this.socket.on('reconnect_failed', () => {
                    console.error('Reconnect fehlgeschlagen nach', this.maxReconnectAttempts, 'Versuchen');
                    alert('Verbindung zum Server verloren. Bitte lade die Seite neu.');
                });

                this.socket.on('connection_success', (data) => {
                    console.log('Verbindung erfolgreich:', data);
                });

                this.socket.on('time_update', (data) => {
                    this.updateTimer(data.time_left);
                });

                this.socket.on('time_out', () => {
                    console.log('Zeit abgelaufen - automatische Antwort');
                    this.handleTimeOut();
                });

                this.socket.on('answer_result', (data) => {
                    console.log('Antwort-Ergebnis erhalten:', data);
                    this.handleAnswerResult(data);
                });

                this.socket.on('error', (data) => {
                    console.error('Socket-Fehler:', data);
                });
            }

            joinQuizSession() {
                if (!this.roomId) {
                    console.error('Keine Room-ID vorhanden');
                    return;
                }

                console.log('Trete Quiz-Session bei:', this.roomId);
                this.socket.emit('join_quiz_session', { 
                    room_id: this.roomId 
                });
            }

            setupEventListeners() {
                const options = document.querySelectorAll('.option');
                options.forEach(option => {
                    option.addEventListener('click', (e) => {
                        if (!this.hasAnswered && !this.isModalOpen) {
                            this.selectOption(e.currentTarget);
                        }
                    });
                });
            }

            selectOption(element) {
                if (this.hasAnswered) {
                    console.log('Bereits geantwortet');
                    return;
                }

                if (!this.isConnected) {
                    console.error('Nicht mit Server verbunden');
                    alert('Verbindungsproblem. Bitte warte einen Moment oder lade die Seite neu.');
                    return;
                }

                console.log('Option ausgewählt:', element.textContent.trim());
                this.hasAnswered = true;
                this.selectedOption = element;

                element.classList.add('selected');
                
                const allOptions = document.querySelectorAll('.option');
                allOptions.forEach(opt => {
                    opt.style.pointerEvents = 'none';
                    opt.style.cursor = 'default';
                    opt.classList.add('answered');
                });

                const selectedAnswer = element.dataset.answer.trim();
                this.submitAnswer(selectedAnswer);
            }

            submitAnswer(answer) {
                if (!this.isConnected) {
                    console.error('Nicht verbunden - kann Antwort nicht senden');
                    this.socket.connect();
                    setTimeout(() => {
                        if (this.isConnected) {
                            this.submitAnswer(answer);
                        } else {
                            alert('Verbindungsproblem. Bitte lade die Seite neu.');
                        }
                    }, 1000);
                    return;
                }

                console.log('Sende Antwort:', answer);
                this.socket.emit('submit_answer', {
                    room_id: this.roomId,
                    answer: answer
                });
            }

            updateTimer(timeLeft) {
                const timerText = document.querySelector('.timer-text');
                const timerProgress = document.querySelector('.timer-progress');
                const timerContainer = document.querySelector('.timer-container');
                
                if (!timerText || !timerProgress) {
                    console.error('Timer-Elemente nicht gefunden');
                    return;
                }

                timerText.textContent = Math.max(0, timeLeft);
                
                const progress = (timeLeft / 30) * 283;
                const offset = Math.max(0, 283 - progress);
                timerProgress.style.strokeDashoffset = offset;
                
                const ratio = Math.max(0, timeLeft / 30);
                const red = Math.floor(255 * (1 - ratio));
                const green = Math.floor(255 * ratio);
                timerProgress.style.stroke = `rgb(${red}, ${green}, 0)`;
                
                if (timeLeft <= 10 && timeLeft > 0) {
                    timerContainer.classList.add('pulse');
                } else {
                    timerContainer.classList.remove('pulse');
                }
            }

            handleTimeOut() {
                if (this.hasAnswered) return;
                
                console.log('Behandle Timeout');
                this.hasAnswered = true;
                
                this.hideConfirmationModal();
                
                const allOptions = document.querySelectorAll('.option');
                allOptions.forEach(opt => {
                    opt.style.pointerEvents = 'none';
                    opt.style.cursor = 'default';
                    opt.classList.add('disabled', 'answered');
                });

                this.submitAnswer('');
            }

            handleAnswerResult(data) {
                if (data.error) {
                    console.error('Antwort-Fehler:', data.error);
                    alert('Ein Fehler ist aufgetreten. Die Seite wird neu geladen.');
                    setTimeout(() => {
                        window.location.reload();
                    }, 1000);
                    return;
                }

                console.log('Verarbeite Antwort-Ergebnis:', data);

                this.updateScore(data.current_score, data.points_earned);
                
                this.highlightAnswers(data);
                
                const isLastQuestion = data.is_last_question || 
                    (this.getCurrentQuestionNumber() >= this.getTotalQuestions());
                
                if (!isLastQuestion) {
                    setTimeout(() => {
                        this.goToNextQuestion();
                    }, 1500);
                } else {
                    console.log('Letzte Frage beantwortet - weiter zur Auswertung');
                    try { 
                        sessionStorage.removeItem('quiz_active'); 
                    } catch (e) {
                        console.warn('sessionStorage remove failed:', e);
                    }
                    this.allowNavigation = true;
                    this.removeBeforeUnloadHandler();
                    setTimeout(() => {
                        window.location.href = "{{ url_for('evaluate_quiz') }}";
                    }, 1500);
                }
            }

            getCurrentQuestionNumber() {
                const progressText = document.querySelector('.progress-bar').textContent;
                const match = progressText.match(/Frage (\d+) von (\d+)/);
                return match ? parseInt(match[1]) : 1;
            }

            getTotalQuestions() {
                const progressText = document.querySelector('.progress-bar').textContent;
                const match = progressText.match(/Frage (\d+) von (\d+)/);
                return match ? parseInt(match[2]) : 30;
            }

            updateScore(newScore, pointsEarned) {
                const scoreDisplay = document.getElementById('score-display');
                if (scoreDisplay) {
                    if (pointsEarned > 0) {
                        const pointsIndicator = document.createElement('div');
                        pointsIndicator.className = 'points-indicator';
                        pointsIndicator.textContent = `+${pointsEarned}`;
                        scoreDisplay.style.position = 'relative';
                        scoreDisplay.appendChild(pointsIndicator);
                        
                        setTimeout(() => {
                            pointsIndicator.remove();
                        }, 1500);
                        
                        scoreDisplay.textContent = `Score: ${newScore}`;
                        scoreDisplay.classList.add('score-positive-update');
                        setTimeout(() => {
                            scoreDisplay.classList.remove('score-positive-update');
                        }, 800);
                    } else {
                        scoreDisplay.textContent = `Score: ${newScore}`;
                    }
                }
            }

            highlightAnswers(result) {
                const allOptions = document.querySelectorAll('.option');
                
                allOptions.forEach(option => {
                    const optionText = option.dataset.answer.trim();
                    
                    option.classList.remove('correct', 'wrong', 'selected');
                    option.style.opacity = '1';
                    
                    option.classList.add('answered');
                    
                    if (optionText === result.correct_answer) {
                        option.classList.add('correct');
                    } 
                    else if (this.selectedOption && this.selectedOption === option) {
                        option.classList.add('wrong');
                    }
                    else {
                        option.classList.add('wrong');
                    }
                });
            }

            resetTimer() {
                if (this.isConnected) {
                    this.socket.emit('reset_timer', {
                        room_id: this.roomId
                    });
                }
            }

            loadNextQuestion() {
                // HINWEIS: CSRF-Token wird jetzt aus dem Meta-Tag geholt
                const csrfToken = document.querySelector('meta[name="csrf-token"]').content;

                fetch('/next_question', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken
                    },
                    body: JSON.stringify({}) // Leerer Body ist ok
                })
                .then(response => {
                    if (!response.ok) {
                        // Bei 405 oder 400 Fehler (z.B. Session abgelaufen)
                        if (response.status === 400 || response.status === 405) {
                            window.location.href = "{{ url_for('homepage') }}";
                        }
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    if (data.redirect) {
                        window.location.href = data.redirect;
                    } else if (data.error) {
                        // Falls der Server einen JSON-Fehler schickt
                        console.error('Fehler vom Server:', data.error);
                        window.location.href = "{{ url_for('homepage') }}";
                    }
                    else {
                        this.updateQuestion(data);
                        // Timer muss serverseitig zurückgesetzt werden (passiert in next_question Route)
                        // Wir müssen hier nichts mehr resetten.
                    }
                })
                .catch(error => {
                    console.error('Fehler beim Laden der nächsten Frage:', error);
                    // Fallback
                    window.location.href = "{{ url_for('homepage') }}";
                });
            }

            updateQuestion(data) {
                const questionTextElement = document.querySelector('.question-text');
                if (questionTextElement) {
                    questionTextElement.textContent = data.question;
                }

                const optionsGrid = document.getElementById('options-grid');
                if (optionsGrid) {
                    optionsGrid.innerHTML = '';

                    data.options.forEach(option => {
                        const optionElement = document.createElement('div');
                        optionElement.className = 'option';
                        optionElement.dataset.answer = option;
                        optionElement.textContent = option;
                        optionsGrid.appendChild(optionElement);
                    });

                    // Wichtig: Event-Listener für die *neuen* Optionen setzen
                    this.setupEventListeners();
                }

                const progressBar = document.querySelector('.progress-bar');
                if (progressBar) {
                    progressBar.textContent = `Frage ${data.progress} von ${data.total_questions}`;
                }

                const scoreDisplay = document.getElementById('score-display');
                if (scoreDisplay) {
                    scoreDisplay.textContent = `Score: ${data.score}`;
                }

                this.hasAnswered = false;
                this.selectedOption = null;

                // update browser URL to current question (1-based)
                try {
                    const newUrl = `/show_question?q=${data.progress}`;
                    // WICHTIG: Wir müssen den *Blocker* neu aufbauen
                    history.replaceState({ quiz: true, q: data.progress, blocker: false }, document.title, newUrl);
                    history.pushState({ quiz: true, q: data.progress, blocker: true }, document.title, newUrl);
                } catch (e) {
                    console.warn('history.pushState für nächste Frage fehlgeschlagen:', e);
                }
            }

            goToNextQuestion() {
                console.log('Gehe zur nächsten Frage');
                
                const progressText = document.querySelector('.progress-bar').textContent;
                const match = progressText.match(/Frage (\d+) von (\d+)/);
                const currentQuestion = parseInt(match[1]);
                const totalQuestions = parseInt(match[2]);
                
                if (currentQuestion < totalQuestions) {
                    this.loadNextQuestion();
                } else {
                    console.log('Letzte Frage beantwortet - weiter zur Auswertung');
                    try { 
                        sessionStorage.removeItem('quiz_active'); 
                    } catch (e) {
                        console.warn('sessionStorage remove failed:', e);
                    }
                    this.allowNavigation = true;
                    this.removeBeforeUnloadHandler();

                    setTimeout(() => {
                        // Der Server leitet uns nach `next_question`
                        // (wenn es die letzte war) automatisch weiter.
                        // Dieser Block wird durch die neue `loadNextQuestion`
                        // Logik eigentlich nicht mehr erreicht.
                        // Stattdessen ruft `loadNextQuestion` -> `updateQuestion` auf
                        // oder leitet weiter.
                        
                        // Doppelte Sicherheit:
                        this.loadNextQuestion();
                    }, 500);
                }
            }

            disconnect() {
                if (this.socket && this.socket.connected) {
                    console.log('Socket wird getrennt');
                    this.socket.disconnect();
                }
                this.removeBeforeUnloadHandler();
            }
        } // Ende QuizManager

        let quizManager;

        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM geladen - initialisiere Quiz');
            quizManager = new QuizManager();

            try {
                const urlParams = new URLSearchParams(window.location.search);
                if (urlParams.get('show_exit_modal') === 'true') {
                    console.log('Modal-Trigger durch URL-Parameter erkannt.');
                    quizManager.modalOpenedByPopstate = true; 
                    quizManager.showConfirmationModal();
                    
                    // KORREKTUR: Benutze die *aktuelle* URL aus dem Browser,
                    // nicht die "Basis"-URL.
                    const currentUrl = window.location.href;
                    const questionNum = quizManager.getCurrentQuestionNumber();

                    // 1. Ersetze den aktuellen History-Eintrag (der vom Server-Redirect kommt)
                    //    mit unserem `blocker: false` state.
                    history.replaceState({ quiz: true, q: questionNum, blocker: false }, document.title, currentUrl);
                    
                    // 2. Pushe den `blocker: true` state, um den "Zurück"-Button abzufangen.
                    history.pushState({ quiz: true, q: questionNum, blocker: true }, document.title, currentUrl);
                }
            } catch(e) {
                console.warn('Fehler beim Prüfen der URL-Parameter:', e);
            }
        });

        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'visible' && quizManager && !quizManager.isConnected) {
                console.log('Tab wieder aktiv - versuche Reconnect');
                quizManager.socket.connect();
            }
        });
    </script>
{% endblock %}
<!DOCTYPE html>

<!--
Grundlegende HTML-Struktur, die von allen anderen Templates erweitert wird
Enthält:
1. Grundlegende Meta-Tags und Links
2. Flash-Message-Container für Benachrichtigungen
3. Globale JavaScript-Funktionen
4. WebSocket-Integration
5. Inaktivitäts-Timer
-->

<html lang="de">
	<head>
		<meta charset="UTF-8" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0"/>

		<!-- CSS -->
		<link rel="stylesheet" href="{{ url_for('static', filename='css/styles_base.css') }}">

		<!-- Favicon Konfiguration -->
		<link rel="apple-touch-icon" sizes="180x180" href="{{ url_for('static', filename='favicon/apple-touch-icon.png') }}">
		<link rel="icon" type="image/png" sizes="32x32" href="{{ url_for('static', filename='favicon/favicon-32x32.png') }}">
		<link rel="icon" type="image/png" sizes="16x16" href="{{ url_for('static', filename='favicon/favicon-16x16.png') }}">
		<link rel="manifest" href="{{ url_for('static', filename='favicon/site.webmanifest') }}">
		<link rel="shortcut icon" href="{{ url_for('static', filename='favicon/favicon.ico') }}">
    
		<!-- Browser-Farbthema -->
		<meta name="msapplication-TileColor" content="#2b5797">
		<meta name="theme-color" content="#1a1a2e">
		
		<!-- CSRF-Schutz-Token -->
		<meta name="csrf-token" content="{{ csrf_token() }}">

		<!-- Sounds (nur rudimentär) -->
		<audio id="clickSound" preload="auto">
			<source src="{{ url_for('static', filename='sounds/button_klick_1.mp3') }}" type="audio/mpeg">
		</audio>

		<title>Clash under Minds</title>

		{%block head%}
		<!-- Block für seiten-spezifische Kopf-Elemente -->
		{% endblock %}
	</head>
	<!-- Datenattribute für JavaScript-Zugriff -->
	<body data-was-correct="{{ 'true' if was_correct else 'false' }}" 
      data-is-logged-in="{{ 'true' if is_logged_in else 'false' }}"
      data-is-admin="{{ 'true' if is_admin else 'false' }}" 
      data-automatic-logout-url="{{ url_for('automatic_logout') }}">

		<!-- ZENTRALER FLASH-MESSAGE CONTAINER -->
		 <!-- Anzeige von Erfolgs-, Fehler- und Info-Nachrichten -->
		<div id="flash-container">
			{% with messages = get_flashed_messages(with_categories=true) %}
				{% if messages %}
					{% for category, message in messages %}
						{% if category == 'permanent' %}
						<!-- Permanente Nachrichten (Inaktivitätswarnungen) -->
						<div class="permanent-message" id="permanent-flash">
							<div class="message-content">{{ message }}</div>
							<button class="close-btn" onclick="closePermanentMessage()">&times;</button>
						</div>
						{% else %}
						<!-- Temporäre Nachrichten mit Auto-Fade-Out -->
						<div class="{% if category == 'error' %}error-message{% elif category == 'info' %}info-message{% else %}success-message{% endif %}">
							{{ message }}
							<div class="custom-progress-bar"></div>
						</div>
						{% endif %}
					{% endfor %}
				{% endif %}
			{% endwith %}
		</div>
		
		{%block body%}
		<!-- Hauptinhalt der Seite wird hier eingefügt -->
		{% endblock %}

		<!-- Socket.io für Echtzeit-Kommunikation (Quiz) -->
		<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.min.js"></script>
		
		<script>
			// Globale Fehlerbehandlung für AJAX-Antworten
			function handleAjaxError(response) {
				if (response.redirect) {
					window.location.href = response.redirect;
					return true;
				}
				if (response.error) {
					createFlashMessage(response.error, 'error');
					return true;
				}
				return false;
			}

			// AJAX-Fehlerbehandlung für Fetch-API
			function handleFetchError(error) {
				console.error('Fetch error:', error);
				createFlashMessage('Ein Netzwerkfehler ist aufgetreten. Bitte versuche es erneut.', 'error');
			}

			// Globale Funktion zum Abspielen von Sounds
			function playSound(soundId) {
				try {
					// Sound-Instanz dynamisch erstellen
					const sound = new Audio("{{ url_for('static', filename='sounds/button_klick_1.mp3') }}");
					sound.volume = 1.0;
					sound.play().catch(e => console.log("Sound play failed:", e));
				} catch (e) {
					console.error("Sound error:", e);
				}
			}

			// Sound-Event für alle sound-Buttons
			document.addEventListener('DOMContentLoaded', () => {
				document.querySelectorAll('.sound-button').forEach(el => {
					el.addEventListener('click', () => {
						playSound('clickSound');
					});
				});
			});

			// Funktion für permanente Nachrichten
			function closePermanentMessage() {
				const permanentMessage = document.getElementById('permanent-flash');
				if (permanentMessage) {
					permanentMessage.style.opacity = '0';
					permanentMessage.style.transition = 'opacity 0.5s ease';
					
					setTimeout(() => {
						if (permanentMessage.parentNode) {
							permanentMessage.parentNode.removeChild(permanentMessage);
						}
					}, 500);
				}
			}

			// Globale Flash-Message Funktion (Info/Error/Success)
			function createFlashMessage(text, type = 'info') {
				const flashContainer = document.getElementById('flash-container');
				if (!flashContainer) return;
				
				// Lösche alle vorhandenen Nachrichten (außer permanent)
				const messages = flashContainer.querySelectorAll('.error-message, .success-message, .info-message');
				messages.forEach(msg => {
					if (!msg.closest('.permanent-message')) {
						msg.remove();
					}
				});
				
				// Neue Nachricht erstellen mit korrekter Klasse
				const messageDiv = document.createElement('div');
				
				// Korrekte Klasse basierend auf type setzen
				if (type === 'error') {
					messageDiv.className = 'error-message'; // rot
				} else if (type === 'success') {
					messageDiv.className = 'success-message'; // grün
				} else {
					messageDiv.className = 'info-message'; // blau
				}
				
				messageDiv.textContent = text;
				
				// Fortschrittsbalken hinzufügen
				const progressBar = document.createElement('div');
				progressBar.className = 'custom-progress-bar';
				messageDiv.appendChild(progressBar);
				
				// Nachricht in den Container einfügen
				flashContainer.appendChild(messageDiv);
				
				// Nachricht nach 5 Sekunden entfernen
				setTimeout(() => {
					messageDiv.style.animation = 'fadeOut 0.5s forwards';
					setTimeout(() => {
						if (flashContainer.contains(messageDiv)) {
							flashContainer.removeChild(messageDiv);
						}
					}, 500);
				}, 5000);
			}

			// Inaktivitäts-Timer (eingeloggte Benutzer, kein Admin)
			document.addEventListener('DOMContentLoaded', function() {
				const body = document.body;
				const isLoggedIn = body.getAttribute('data-is-logged-in') === 'true';
				const isAdmin = body.getAttribute('data-is-admin') === 'true';
				const automaticLogoutUrl = body.getAttribute('data-automatic-logout-url');
				
				// Logik nur starten, wenn eingeloggt und kein Admin
				if (isLoggedIn && !isAdmin) {
					let warningTimer;
					let logoutTimer;
					
					// Konfiguration in Millisekunden
					const timeTotal = 30 * 60 * 1000;    // 30 Minuten bis Logout
					const timeWarning = 25 * 60 * 1000;  // 25 Minuten bis Warnung
					
					let warningMessageElement = null;

					function startTimers() {
						// Warnung nach 25 Min
						warningTimer = setTimeout(showInactivityWarning, timeWarning);
						// Logout nach 30 Min
						logoutTimer = setTimeout(logoutDueToInactivity, timeTotal);
					}

					function resetInactivityTimer() {
						clearTimeout(warningTimer);
						clearTimeout(logoutTimer);
						
						// Wenn eine Warnung angezeigt wird, diese entfernen, da User wieder aktiv
						if (warningMessageElement) {
							// Animation für sanftes Ausblenden (optional)
							warningMessageElement.style.opacity = '0';
							setTimeout(() => {
								if (warningMessageElement && warningMessageElement.parentNode) {
									warningMessageElement.parentNode.removeChild(warningMessageElement);
								}
								warningMessageElement = null;
							}, 300);
						}
						startTimers(); // Timer neustarten
					}

					function showInactivityWarning() {
						// Berechne die Dauer in Sekunden (5 min * 60 = 300s)
						const durationSeconds = (timeTotal - timeWarning) / 1000;
						const minutesLeft = Math.round(durationSeconds / 60);
						
						warningMessageElement = document.createElement('div');
						warningMessageElement.className = 'warning-message'; 
						warningMessageElement.style.zIndex = '10000';
						
						warningMessageElement.innerHTML = `
							Inaktivitätswarnung: Sie werden in ${minutesLeft} Minuten automatisch abgemeldet.
							<div class="custom-progress-bar" style="animation: progressBar ${durationSeconds}s linear forwards;"></div>
						`;
						
						const container = document.getElementById('flash-container');
						if (container) {
							container.appendChild(warningMessageElement);
						}
					}

					function logoutDueToInactivity() {
						// Sende User zum Logout-Endpunkt
						window.location.href = automaticLogoutUrl;
					}

					// Timer initial starten
					startTimers();

					// Event-Listener für Aktivität (Maus & Tastatur)
					const events = ['mousemove', 'mousedown', 'keypress', 'touchstart', 'scroll'];
					
					// Nicht bei jedem Pixel Mausbewegung feuern, sondern maximal alle 500ms
					let eventTimeout;
					const eventHandler = () => {
						if (!eventTimeout) {
							eventTimeout = setTimeout(() => {
								resetInactivityTimer();
								eventTimeout = null;
							}, 500);
						}
					};
					events.forEach(event => {
						document.addEventListener(event, eventHandler);
					});
				} else if (isAdmin) {
					console.log("Admin erkannt: Automatischer Logout deaktiviert.");
				}
			});

			// Zeit konvertieren ISO-Format zu lokaler Zeit
			function formatIsoToLocal(iso) {
				if (!iso) return null;
				const d = new Date(iso);
				if (isNaN(d)) return null;
				const day = String(d.getDate()).padStart(2, '0');
				const month = String(d.getMonth() + 1).padStart(2, '0');
				const year = d.getFullYear();
				const hours = String(d.getHours()).padStart(2, '0');
				const mins = String(d.getMinutes()).padStart(2, '0');
				return `${day}.${month}.${year} ${hours}:${mins}`;
			}

			// Konvertiert alle UTC-Zeit-Elemente auf der Seite
			function convertUtcTimeElements(root = document) {
				root.querySelectorAll && root.querySelectorAll('time.utc-time').forEach(el => {
					const iso = el.dataset.iso || el.getAttribute('datetime') || el.textContent.trim();
					const formatted = formatIsoToLocal(iso);
					if (formatted) {
						el.textContent = formatted;
						el.setAttribute('datetime', iso);
						el.classList.remove('utc-time');
						el.classList.add('utc-time-done');
					}
				});
			}

			// Zeitkonvertierung bei Seitenladung ausführen
			document.addEventListener('DOMContentLoaded', () => convertUtcTimeElements());
		</script>

		<script>
		// ============================================
		// QUIZ-SCHUTZ (Verhindert unerlaubtes Verlassen)
		// ============================================

		window.addEventListener('pageshow', function(e) {
			try {
				// Prüfe, ob wir das Quiz gerade absichtlich verlassen haben
				const cancelledIntentionally = sessionStorage.getItem('quiz_cancelled_intentionally') === '1';
				if (cancelledIntentionally) {
					// Flag sofort löschen und nichts tun (Navigation erlauben)
					sessionStorage.removeItem('quiz_cancelled_intentionally');
					return; 
				}

				const path = location.pathname || '/';
				const fromBFCache = !!e.persisted;

				// BFCache + Index => serverseitig ausloggen
				if (fromBFCache && path === '/') {
					// Nutze vorhandene Logout-Route (stop Timer + Session löschen)
					window.location.href = "{{ url_for('logout') }}";
					return;
				}

			} catch (err) {
				console.warn('pageshow handler failed', err);
			}
		});
		</script>
	</body>
</html>